local mod = get_mod("SpecialsTracker")

require("scripts/foundation/utilities/color")
local UISettings = require("scripts/settings/ui/ui_settings")
local UIWorkspaceSettings = require("scripts/settings/ui/ui_workspace_settings")
local UIWidget = require("scripts/managers/ui/ui_widget")

local HudElementSpecialsTracker = class("HudElementSpecialsTracker", "HudElementBase")

local line_spacing = 3
local font_height_size = 25

local text_pass_width = 60
local number_pass_width = 30
local padding_width = 20

local text_pass_size = { text_pass_width, font_height_size }
local number_pass_size = { number_pass_width, font_height_size }

local container_size = {
	text_pass_width + number_pass_width + padding_width
,
	math.max(0, #mod.interesting_breed_names.array * (text_pass_size[2] + line_spacing) - line_spacing)
}

mod.tracked_units.init()


local scenegraph_definition = {
	screen = UIWorkspaceSettings.screen,
	container = {
		parent = "screen",
		scale = "fit",
		vertical_alignment = "center",
		horizontal_alignment = "center",
		size = container_size,
		position = {
			0,
			0,
			0,
		},
	},
}

local breed_widget = function(breed_name)
	-- Argument: a breed_name
	-- Returns: A widget built from the two passes of breed_name
	-- NB: Its position and visibility will be upgraded as is needed in the init and update methods of the UI element

	local breed_passes =
		{
			{
			value_id = breed_name.."_text",
			style_id = breed_name.."_text",
			pass_type = "text",
			value = mod:localize(breed_name.."_overlay"),
			style = {
				text_color = {255,255,255,255},
				font_size = 25, --mod:get("font_size") or 25,
				drop_shadow = true,
				font_type = "machine_medium", --mod:get("font") or "machine_medium",
				size = text_pass_size,
				text_horizontal_alignment = "left",
				text_vertical_alignment = "top",
				horizontal_alignment = "left",
				vertical_alignment = "top",
				offset = {
					0
				,
					0
				},
			},
			visibility_function = function(content, style)
				-- Both should be the same:
				return mod.tracked_units.breeds_inverted_table[breed_name]
				-- return mod:get(breed_name)
			end,
		},
		{
			value_id = breed_name.."_value",
			style_id = breed_name.."_value",
			pass_type = "text",
			value = "-",
			style = {
				text_color = {255,255,255,255},
				font_size = 25, --mod:get("font_size") or 25,
				drop_shadow = true,
				font_type = "machine_medium", --mod:get("font") or "machine_medium",
				size = number_pass_size,
				text_horizontal_alignment = "left",
				text_vertical_alignment = "top",
				horizontal_alignment = "left",
				vertical_alignment = "top",
				offset = {
					container_size[1] - number_pass_size[1]
				,
					0
				},
			},
			visibility_function = function(content, style)
				-- Both should be the same:
				-- return mod.tracked_units.breeds_inverted_table[breed_name]
				return mod:get(breed_name)
			end,
		},
	}
	return(
		UIWidget.create_definition(
			breed_passes
		,
			"container"
		)
	)
end


local widget_definitions = {}
-- widget_definitions.table["widget_".breed_name] is the widget containing the text and number passes of breed_name
-- widget_definitions.init() creates the widget table, but nothing more (all widgets will have the same position)

widget_definitions.table = {}

widget_definitions.init = function()
	-- Create the definition for *all* widgets, which have a built-in visibility function
	for _, breed_name in pairs(mod.interesting_breed_names.array) do
		widget_definitions.table["widget_"..breed_name] = breed_widget(breed_name)
	end
end


HudElementSpecialsTracker.init = function(self, parent, draw_layer, start_scale)
	-- Create widgets for *all trackable* breeds
	-- Does NOT reposition the widgets - we count on the update method for that, which is why mod.widgets_pos_need_update is initialised to true in the main file
	widget_definitions.init()
	HudElementSpecialsTracker.super.init(self, parent, draw_layer, start_scale, {
		scenegraph_definition = scenegraph_definition,
		widget_definitions = widget_definitions.table,
	})
end

HudElementSpecialsTracker.update = function(self, dt, t, ui_renderer, render_settings, input_service)
	HudElementSpecialsTracker.super.update(self, dt, t, ui_renderer, render_settings, input_service)
	if mod.widgets_pos_need_update then
		mod.tracked_units.init()
		for i, breed_name in pairs(mod.tracked_units.breeds_array) do
			local y_offset = (i-1) * (text_pass_size[2] + line_spacing)
			local widget = self._widgets_by_name["widget_"..breed_name]
			widget.style[breed_name.."_text"].offset[2] = y_offset
			widget.style[breed_name.."_value"].offset[2] = y_offset
			-- widget.visibility_function = function(content,style)
					-- Both should be the same:
					-- return mod.tracked_units.breeds_inverted_table[breed_name]
					-- return mod:get(breed_name)
			-- end
		end
		mod.widgets_pos_need_update = false
	end
	for _, breed_name in pairs(mod.tracked_units.breeds_array) do
		local unit_number_or_nil = mod.tracked_units.unit_count[breed_name]
		-- This should never be nil if all the different functions are called at the right time, but might as well catch the error if it occurs
		local active_units_text = unit_number_or_nil and tostring(unit_number_or_nil) or "X"
		self._widgets_by_name["widget_"..breed_name].content[breed_name.."_value"] = active_units_text
	end
end

return HudElementSpecialsTracker